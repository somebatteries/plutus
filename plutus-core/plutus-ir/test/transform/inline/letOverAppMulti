{- 
funApp gets inlined because it only occurs once.
idFun and k should not get inlined by the unconditional inline optimization because they occur more
than once. They should get inlined by the optimization that inlines fully applied functions because
they are fully applied.
k being inline verifies that an over-applied function still gets inline.

let 
    idFun :: Integer -> Integer
    idFun = \y.y
    funApp :: (Integer -> Integer) -> (Integer -> Integer)
    funApp = \x.idFun
    k :: (Integer -> Integer) -> (Integer -> Integer)
    k = funApp
in k idFun 6
-}

(let
    (nonrec)
    (termbind
      (strict)
      (vardecl idFun (fun (con integer) (con integer)))
      (lam y (con integer) y)
    )

    (termbind
      (strict)
      (vardecl
        funApp
        (fun
          (fun (con integer) (con integer)) (fun (con integer) (con integer))
        )
      )
      (lam
        x
        (fun (con integer) (con integer))
        (idFun)
      )
    )

    (termbind
      (strict)
      (vardecl
        k
        (fun
          (fun (con integer) (con integer)) (fun (con integer) (con integer))
        )
      )
      (funApp)
    )
    
    [ [ k idFun ] (con integer 6) ]
)